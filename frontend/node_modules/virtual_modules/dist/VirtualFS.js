"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vfs = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const module_1 = __importDefault(require("module"));
const framework_1 = require("@inceptjs/framework");
const memfs_1 = require("memfs");
const patchFS_1 = __importDefault(require("./patchFS"));
const Exception_1 = __importDefault(require("./Exception"));
class VirtualFS extends memfs_1.Volume {
    constructor() {
        super(...arguments);
        this._emitter = new framework_1.EventEmitter;
        this._revertFS = null;
        this._transformers = [];
        this._originals = {
            existsSync: fs_1.default.existsSync.bind(fs_1.default)
        };
    }
    addRule(test, callback) {
        Exception_1.default.require(typeof test === 'function' || test instanceof RegExp, 'Argument 1 expecting RegExp or Function');
        Exception_1.default.require(typeof callback === 'function', 'Argument 2 expecting Function');
        this._transformers.push({ test, callback });
        return this;
    }
    exists(path, callback) {
        this._resolveFile(path);
        return super.exists(path, callback);
    }
    existsSync(path) {
        this._resolveFile(path);
        return super.existsSync(path);
    }
    lstat(path, ...args) {
        this._resolveFile(path);
        return super.lstat(path, ...args);
    }
    lstatSync(path, options) {
        this._resolveFile(path);
        return super.lstatSync(path);
    }
    modulePaths(pathname, parent) {
        parent = parent || path_1.default.dirname(pathname);
        const module = new module_1.default(path_1.default.dirname(parent));
        module.paths = module_1.default._nodeModulePaths(pathname, module);
        return module_1.default._resolveLookupPaths(pathname, module);
    }
    patchFS() {
        if (typeof this._revertFS === 'function') {
            return this;
        }
        this._revertFS = (0, patchFS_1.default)(this);
        this._originals._findPath = module_1.default._findPath;
        module_1.default._findPath = this._findPath.bind(this);
        return this;
    }
    readFileSync(id, ...args) {
        this._resolveFile(id);
        return this.transform(id, super.readFileSync(id, ...args));
    }
    readFile(id, ...args) {
        this._resolveFile(id);
        if (typeof args[args.length - 1] === 'function') {
            const callback = args[args.length - 1];
            args[args.length - 1] = (error, results) => {
                if (results) {
                    results = this.transform(id, results);
                }
                callback(error, results);
            };
        }
        super.readFile(id, ...args);
    }
    resolvePath(request, paths = [], context = fs_1.default) {
        let filename;
        if (!(filename = tryAbsolute(request, context))
            && !(filename = tryRelative(request, paths, context))
            && !(filename = tryModule(request, paths, context))) {
            return false;
        }
        return filename;
    }
    resolveModule(name, parent) {
        const paths = this.modulePaths(name, parent);
        for (const pathname of paths) {
            const folder = path_1.default.join(pathname, name);
            if (fs_1.default.existsSync(folder)) {
                return folder;
            }
        }
        return false;
    }
    revertPatch() {
        if (typeof this._revertFS === 'function') {
            this._revertFS();
            this._revertFS = null;
        }
        if (typeof this._originals._findPath === 'function') {
            module_1.default._findPath = this._originals._findPath;
            delete this._originals._findPath;
        }
        return this;
    }
    route(path, router) {
        Exception_1.default.require(typeof path === 'string', 'Argument 1 expected String');
        Exception_1.default.require(typeof router === 'function', 'Argument 2 expected String');
        const pattern = path
            .replace(/(\:[a-zA-Z0-9\-_]+)/g, '*')
            .replaceAll('*', '([^/]+)')
            .replaceAll('([^/]+)([^/]+)', '(.*)');
        const event = new RegExp(`^${pattern}/*$`, 'ig');
        this._emitter.on(event, router);
        return this;
    }
    routeParams(file, route) {
        Exception_1.default.require(typeof file === 'string', 'Argument 1 expected String');
        Exception_1.default.require(typeof route === 'string', 'Argument 2 expected String');
        const pattern = route
            .replace(/(\:[a-zA-Z0-9\-_]+)/g, '*')
            .replaceAll('*', '([^/]+)')
            .replaceAll('([^/]+)([^/]+)', '(.*)');
        const params = {
            file: file,
            pattern: new RegExp(`^${pattern}/*$`, 'ig'),
            args: [],
            params: {}
        };
        const matches = Array.from(params.file.matchAll(pattern));
        if (!Array.isArray(matches[0]) || !matches[0].length) {
            return params;
        }
        const map = Array.from(route.matchAll(/(\:[a-zA-Z0-9\-_]+)|(\*\*)|(\*)/g)).map(match => match[0]);
        matches[0].slice().forEach((param, i) => {
            if (!i) {
                return;
            }
            if (typeof map[i - 1] !== 'string'
                || map[i - 1].indexOf('*') === 0) {
                if (param.indexOf('/') === -1) {
                    return params.args.push(param);
                }
                return Array.prototype.push.apply(params.args, param.split('/'));
            }
            if (typeof map[i - 1] === 'string') {
                params.params[map[i - 1].substr(1)] = param;
            }
        });
        return params;
    }
    stat(path, ...args) {
        this._resolveFile(path);
        return super.stat(path, ...args);
    }
    statSync(path, options) {
        this._resolveFile(path);
        return super.statSync(path);
    }
    transform(file, body) {
        for (const transformer of this._transformers) {
            const valid = typeof transformer.test === 'function'
                ? transformer.test(file)
                : transformer.test.test(file);
            if (valid) {
                const transformed = transformer.callback(file, body);
                if (typeof transformed === 'string') {
                    body = transformed;
                }
            }
        }
        return body;
    }
    _findPath(request, paths, isMain) {
        let filename = this._originals._findPath.call(module_1.default, request, paths, isMain);
        if (filename) {
            return filename;
        }
        if (!(filename = this.resolvePath(request, paths, this))) {
            return false;
        }
        const cacheKey = request + '\x00' + paths.join('\x00');
        module_1.default._pathCache[cacheKey] = filename;
        return filename;
    }
    _resolveFile(file) {
        if (this._originals.existsSync(file) || super.existsSync(file)) {
            return this;
        }
        const response = new framework_1.Response();
        this._emitter.emitSync(file, file, response, this);
        if (response.filled) {
            const dirname = path_1.default.dirname(file);
            if (!super.existsSync(dirname)) {
                this.mkdirSync(dirname, { recursive: true });
            }
            this.writeFileSync(file, response.body);
        }
        return this;
    }
}
exports.default = VirtualFS;
function tryAbsolute(request, fs) {
    if (!path_1.default.isAbsolute(request)) {
        return false;
    }
    let file = request;
    if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
        return file;
    }
    file = tryVariants(file, fs);
    if (file) {
        return file;
    }
    return false;
}
function tryRelative(request, paths, fs) {
    if (!paths.length || !/^\.{1,2}[\/\\]/.test(request)) {
        return false;
    }
    let file = path_1.default.resolve(paths[0], request);
    if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
        return file;
    }
    file = tryVariants(file, fs);
    if (file) {
        return file;
    }
    return false;
}
function tryModule(request, paths, fs) {
    for (const pathname of paths) {
        let file = path_1.default.resolve(pathname, request);
        if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
            return file;
        }
        file = tryVariants(file, fs);
        if (file) {
            return file;
        }
    }
    return false;
}
function tryVariants(request, fs) {
    let file = tryExtensions(request, fs);
    if (file) {
        return file;
    }
    file = tryIndex(request, fs);
    if (file) {
        return file;
    }
    return false;
}
function tryIndex(request, fs) {
    let file = `${request}/index`;
    if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
        return file;
    }
    file = tryExtensions(file, fs);
    if (file) {
        return file;
    }
    return false;
}
function tryExtensions(request, fs) {
    let file = `${request}.js`;
    if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
        return file;
    }
    file = `${request}.jsx`;
    if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
        return file;
    }
    file = `${request}.json`;
    if (fs.existsSync(file) && fs.lstatSync(file).isFile()) {
        return file;
    }
    return false;
}
const vfs = new VirtualFS;
exports.vfs = vfs;

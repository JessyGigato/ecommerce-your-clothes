"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.File = void 0;
class Store {
    constructor(data = {}) {
        this.data = data;
        this.withArgs = new Args(this);
        this.withFormData = new FormData(this);
        this.withPath = new Path(this);
        this.withQuery = new Query(this);
    }
    each(...path) {
        return __awaiter(this, void 0, void 0, function* () {
            const callback = path.pop();
            let list = this.get(...path);
            if (!list
                || Array.isArray(list) && !list.length
                || typeof list === 'string' && !list.length
                || typeof list === 'object' && !Object.keys(list).length) {
                return false;
            }
            for (let key in list) {
                if ((yield callback(list[key], key)) === false) {
                    return false;
                }
            }
            return true;
        });
    }
    get(...path) {
        if (!path.length) {
            return this.data;
        }
        if (!this.has(...path)) {
            return null;
        }
        const last = path.pop();
        let pointer = this.data;
        path.forEach(step => pointer = pointer[step]);
        return pointer[last];
    }
    has(...path) {
        if (!path.length) {
            return false;
        }
        let found = true;
        const last = path.pop();
        let pointer = this.data;
        path.forEach(step => {
            if (!found) {
                return;
            }
            if (typeof pointer[step] !== 'object') {
                found = false;
                return;
            }
            pointer = pointer[step];
        });
        return !(!found || typeof pointer[last] === 'undefined');
    }
    remove(...path) {
        if (!path.length) {
            return this;
        }
        if (!this.has(...path)) {
            return this;
        }
        const last = path.pop();
        let pointer = this.data;
        path.forEach(step => {
            pointer = pointer[step];
        });
        delete pointer[last];
        return this;
    }
    set(...path) {
        if (path.length < 1) {
            return this;
        }
        if (typeof path[0] === 'object') {
            Object.keys(path[0]).forEach(key => {
                this.set(key, path[0][key]);
            });
            return this;
        }
        const value = path.pop();
        let last = path.pop(), pointer = this.data;
        path.forEach((step, i) => {
            if (step === null || step === '') {
                path[i] = step = Object.keys(pointer).length;
            }
            if (typeof pointer[step] !== 'object') {
                pointer[step] = {};
            }
            pointer = pointer[step];
        });
        if (last === null || last === '') {
            last = Object.keys(pointer).length;
        }
        pointer[last] = value;
        pointer = this.data;
        path.forEach((step) => {
            const next = pointer[step];
            if (!Array.isArray(next) && shouldBeAnArray(next)) {
                pointer[step] = makeArray(next);
            }
            else if (Array.isArray(next) && !shouldBeAnArray(next)) {
                pointer[step] = makeObject(next);
            }
            pointer = pointer[step];
        });
        return this;
    }
}
exports.default = Store;
class File {
    constructor(file) {
        this.data = file.data;
        this.name = file.name;
        this.type = file.type;
    }
}
exports.File = File;
class Args {
    constructor(store) {
        this.store = store;
    }
    set(...path) {
        if (path.length < 1) {
            return this.store;
        }
        let skip = path.pop();
        if (typeof skip !== 'number') {
            path.push(skip);
            skip = 0;
        }
        let args = path.pop();
        if (typeof args === 'string') {
            args = args.split(' ');
        }
        let key, index = 0, i = skip, j = args.length;
        for (; i < j; i++) {
            const arg = args[i];
            const equalPosition = arg.indexOf('=');
            if (arg.substr(0, 2) === '--') {
                if (equalPosition === -1) {
                    key = arg.substr(2);
                    if ((i + 1) < j && args[i + 1][0] !== '-') {
                        this._format(path, key, args[i + 1]);
                        i++;
                        continue;
                    }
                    this._format(path, key, true);
                    continue;
                }
                this._format(path, arg.substr(2, equalPosition - 2), arg.substr(equalPosition + 1));
                continue;
            }
            if (arg.substr(0, 1) === '-') {
                if (arg.substr(2, 1) === '=') {
                    this._format(path, arg.substr(1, 1), arg.substr(3));
                    continue;
                }
                const chars = arg.substr(1);
                for (let k = 0; k < chars.length; k++) {
                    key = chars[k];
                    this._format(path, key, true);
                }
                if ((i + 1) < j && args[i + 1][0] !== '-') {
                    this._format(path, key, args[i + 1], true);
                    i++;
                }
                continue;
            }
            if (equalPosition !== -1) {
                this._format(path, arg.substr(0, equalPosition), arg.substr(equalPosition + 1));
                continue;
            }
            if (arg.length) {
                this._format(path, index++, arg);
            }
        }
        return this.store;
    }
    _format(path, key, value, override) {
        switch (true) {
            case typeof value !== 'string':
                break;
            case value === 'true':
                value = true;
                break;
            case value === 'false':
                value = false;
                break;
            case !isNaN(value) && !isNaN(parseFloat(value)):
                value = parseFloat(value);
                break;
            case !isNaN(value) && !isNaN(parseInt(value)):
                value = parseInt(value);
                break;
        }
        if (path.length) {
            key = path.join('.') + '.' + key;
        }
        key = String(key);
        const withPath = this.store.withPath;
        if (!withPath.has(key) || override) {
            withPath.set(key, value);
            return this.store;
        }
        const current = withPath.get(key);
        if (!Array.isArray(current)) {
            withPath.set(key, [current, value]);
            return this.store;
        }
        current.push(value);
        withPath.set(key, current);
        return this.store;
    }
}
class Path {
    constructor(store) {
        this.store = store;
    }
    each(notation, callback, separator = '.') {
        return __awaiter(this, void 0, void 0, function* () {
            const path = notation.split(separator);
            return yield this.store.each(...path, callback);
        });
    }
    get(notation, separator = '.') {
        const path = notation.split(separator);
        return this.store.get(...path);
    }
    has(notation, separator = '.') {
        const path = notation.split(separator);
        return this.store.has(...path);
    }
    remove(notation, separator = '.') {
        const path = notation.split(separator);
        return this.store.remove(...path);
    }
    set(notation, value, separator = '.') {
        const path = notation.split(separator);
        return this.store.set(...path, value);
    }
}
class Query {
    constructor(store) {
        this.store = store;
    }
    set(...path) {
        if (path.length < 1) {
            return this.store;
        }
        const query = path.pop();
        const separator = '~~' + Math.floor(Math.random() * 10000) + '~~';
        query.split(/\&/gi).forEach((filter) => {
            const [key, value] = filter.split('=', 2);
            const keys = key
                .replace(/\]\[/g, separator)
                .replace('[', separator)
                .replace(/\[/g, '')
                .replace(/\]/g, '')
                .split(separator);
            keys.map((key) => {
                const index = parseInt(key);
                if (!isNaN(index) && key.indexOf('.') === -1) {
                    return index;
                }
                return key;
            });
            const paths = path.concat(keys);
            if (/(^\{.*\}$)|(^\[.*\]$)/.test(value)) {
                try {
                    return query.set(...paths, JSON.parse(value));
                }
                catch (e) { }
            }
            if (!isNaN(parseFloat(value))) {
                this.store.set(...paths, parseFloat(value));
            }
            else if (value === 'true') {
                this.store.set(...paths, true);
            }
            else if (value === 'false') {
                this.store.set(...paths, false);
            }
            else if (value === 'null') {
                this.store.set(...paths, null);
            }
            else {
                this.store.set(...paths, value);
            }
        });
        return this.store;
    }
}
class FormData {
    constructor(store) {
        this.store = store;
    }
    set(...path) {
        if (path.length < 1) {
            return this.store;
        }
        const formData = path.pop();
        const formDataBuffer = typeof formData === 'string'
            ? Buffer.from(formData)
            : formData;
        const boundary = this._getBoundary(formDataBuffer);
        let part = [];
        for (let i = 0; i < formDataBuffer.length; i++) {
            const line = this._getLine(formDataBuffer, i);
            if (line === null) {
                break;
            }
            const buffer = line.buffer;
            if (buffer.toString().indexOf(boundary) === 0) {
                if (part.length) {
                    this._setPart(path, this._getPart(part));
                }
                if (buffer.toString() === `${boundary}--`) {
                    break;
                }
                part = [];
            }
            else {
                part.push(buffer);
            }
            i = line.i;
        }
        return this.store;
    }
    _getBoundary(buffer) {
        var _a;
        const boundary = (_a = this._getLine(buffer, 0)) === null || _a === void 0 ? void 0 : _a.buffer;
        if (!boundary) {
            return null;
        }
        return boundary.slice(0, boundary.length - 1).toString();
    }
    _getLine(buffer, i) {
        const line = [];
        for (; i < buffer.length; i++) {
            const current = buffer[i];
            line.push(current);
            if (current === 0x0a || current === 0x0d) {
                return { i, buffer: Buffer.from(line) };
            }
        }
        if (line.length) {
            return { i, buffer: Buffer.from(line) };
        }
        return null;
    }
    _getPart(lines) {
        var _a;
        const headerLines = [];
        do {
            headerLines.push((_a = lines.shift()) === null || _a === void 0 ? void 0 : _a.toString());
        } while (lines.length
            && !(lines[0].length === 1
                && (lines[0][0] === 0x0a
                    || lines[0][0] === 0x0d)));
        const last = lines[lines.length - 1];
        lines[lines.length - 1] = last.slice(0, last.length - 1);
        const body = Buffer.concat(lines.slice(1));
        const headers = {};
        for (const line of headerLines) {
            if (line && line.indexOf(':') !== -1) {
                const [key, value] = line.toString().split(':', 2);
                headers[key.trim().toLowerCase()] = value.trim();
            }
        }
        const form = {};
        if (typeof headers['content-disposition'] === 'string') {
            headers['content-disposition'].split(';').forEach(disposition => {
                const matches = disposition
                    .trim()
                    .match(/^([a-zA-Z0-9_\-]+)=["']([^"']+)["']$/);
                if (matches && matches.length > 2) {
                    form[matches[1]] = matches[2];
                }
            });
        }
        return { headers, body, form };
    }
    _setPart(path, part) {
        if (!part.form.name) {
            return this;
        }
        const separator = '~~' + Math.floor(Math.random() * 10000) + '~~';
        const keys = part.form.name
            .replace(/\]\[/g, separator)
            .replace('[', separator)
            .replace(/\[/g, '')
            .replace(/\]/g, '')
            .split(separator);
        keys.map((key) => {
            const index = parseInt(key);
            if (!isNaN(index) && key.indexOf('.') === -1) {
                return index;
            }
            return key;
        });
        const paths = path.concat(keys);
        if (!part.form.filename) {
            const value = part.body.toString();
            if (/(^\{.*\}$)|(^\[.*\]$)/.test(value)) {
                try {
                    return this.store.set(...paths, JSON.parse(value));
                }
                catch (e) { }
            }
            if (!isNaN(parseFloat(value))) {
                this.store.set(...paths, parseFloat(value));
            }
            else if (value === 'true') {
                this.store.set(...paths, true);
            }
            else if (value === 'false') {
                this.store.set(...paths, false);
            }
            else if (value === 'null') {
                this.store.set(...paths, null);
            }
            else {
                this.store.set(...paths, value);
            }
            return this;
        }
        this.store.set(...paths, new File({
            data: part.body,
            name: part.form.filename,
            type: part.headers['content-type']
        }));
    }
}
function makeArray(object) {
    const array = [];
    const keys = Object.keys(object);
    keys.sort();
    keys.forEach(function (key) {
        array.push(object[key]);
    });
    return array;
}
function makeObject(array) {
    return Object.assign({}, array);
}
function shouldBeAnArray(object) {
    if (typeof object !== 'object') {
        return false;
    }
    const length = Object.keys(object).length;
    if (!length) {
        return false;
    }
    for (let i = 0; i < length; i++) {
        if (typeof object[i] === 'undefined') {
            return false;
        }
    }
    return true;
}

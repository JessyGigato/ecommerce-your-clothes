export default class Reflection {
    static assign(destination: Record<string, any>, ...sources: Record<string, any>[]): Record<string, any>;
    static clone(object: Record<string, any>): Record<string, any>;
    static extends(destination: Function, ...sources: Function[]): Record<string, any>;
    static filter(destination: Record<string, any>, callback: Function): Record<string, any>;
    static getArgumentNamesOf(definition: Function): string[];
    static getMethodNamesOf(definition: Definable, force?: boolean): string[];
    static getPropertyNamesOf(definition: Definable, force?: boolean): string[];
    static getPrototypeOf(definition: Definable, force?: boolean): string[];
    static implements: (child: Record<string, any>, ...parents: Definable[]) => boolean;
    static isClass(definition: Function): boolean;
    static map(destination: Record<string, any>, source: Record<string, any> | Function, callback?: Function): Record<string, any>;
    static reflect(definition: Definable): Reflection;
    static rename(definition: Function, name: string): Function;
    definition: Definable;
    constructor(definition: Definable);
    assign(...sources: Record<string, any>[]): Reflection;
    clone(): Record<string, any>;
    extends(...sources: Function[]): Reflection;
    filter(callback: Function): Reflection;
    get(): Definable;
    getArgumentNames(): string[];
    getMethodNames(force: boolean): string[];
    getPropertyNames(force: boolean): string[];
    getPrototype(force: boolean): string[];
    implements(...parents: Definable[]): boolean;
    isClass(): boolean;
    map(source: Record<string, any> | Function, callback?: Function): Reflection;
    rename(name: string): Reflection;
}
export declare type Definable = Function | Record<string, any>;

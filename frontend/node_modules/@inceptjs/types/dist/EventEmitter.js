"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Status_1 = __importDefault(require("./Status"));
const TaskQueue_1 = __importDefault(require("./TaskQueue"));
const Exception_1 = __importDefault(require("./Exception"));
class EventEmitter {
    constructor() {
        this.listeners = {};
        this.event = {
            event: 'idle',
            pattern: 'idle',
            parameters: []
        };
        this.regexp = [];
    }
    static makeQueue() {
        return new TaskQueue_1.default();
    }
    emit(event, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            Exception_1.default.require(typeof event === 'string', 'Argument 1 expected String');
            const matches = this.match(event);
            if (!Object.keys(matches).length) {
                return Status_1.default.NOT_FOUND;
            }
            const queue = EventEmitter.makeQueue();
            Object.keys(matches).forEach((key) => {
                const match = matches[key];
                const event = match.pattern;
                if (typeof this.listeners[event] === 'undefined') {
                    return;
                }
                match.args = args;
                this.listeners[event].forEach(listener => {
                    queue.add((...args) => __awaiter(this, void 0, void 0, function* () {
                        this.event = Object.assign({}, match, listener);
                        if ((yield listener.callback(...args)) === false) {
                            return false;
                        }
                    }), listener.priority);
                });
            });
            return yield queue.run(...args);
        });
    }
    emitSync(event, ...args) {
        Exception_1.default.require(typeof event === 'string', 'Argument 1 expected String');
        const matches = this.match(event);
        if (!Object.keys(matches).length) {
            return Status_1.default.NOT_FOUND;
        }
        const queue = EventEmitter.makeQueue();
        Object.keys(matches).forEach((key) => {
            const match = matches[key];
            const event = match.pattern;
            if (typeof this.listeners[event] === 'undefined') {
                return;
            }
            match.args = args;
            this.listeners[event].forEach(listener => {
                queue.add((...args) => {
                    this.event = Object.assign({}, match, listener);
                    if (listener.callback(...args) === false) {
                        return false;
                    }
                }, listener.priority);
            });
        });
        return queue.runSync(...args);
    }
    inspect(event) {
        Exception_1.default.require(typeof event === 'string', 'Argument 1 expected String');
        const matches = this.match(event);
        if (!Object.keys(matches).length) {
            return [];
        }
        const queue = EventEmitter.makeQueue();
        Object.keys(matches).forEach(key => {
            const event = matches[key].pattern;
            if (typeof this.listeners[event] === 'undefined') {
                return;
            }
            this.listeners[event].forEach(listener => {
                queue.add(listener.callback, listener.priority);
            });
        });
        return queue.tasks;
    }
    match(event) {
        Exception_1.default.require(typeof event === 'string', 'Argument 1 expected String');
        const matches = {};
        if (typeof this.listeners[event] !== 'undefined') {
            matches[event] = {
                event: event,
                pattern: event,
                parameters: []
            };
        }
        this.regexp.forEach(pattern => {
            const regexp = new RegExp(pattern.substr(pattern.indexOf('/') + 1, pattern.lastIndexOf('/') - 1), pattern.substr(pattern.lastIndexOf('/') + 1));
            let match, parameters;
            if (regexp.flags.indexOf('g') === -1) {
                match = event.match(regexp);
                if (!match || !match.length) {
                    return;
                }
                parameters = [];
                if (Array.isArray(match)) {
                    parameters = match.slice();
                    parameters.shift();
                }
            }
            else {
                match = Array.from(event.matchAll(regexp));
                if (!Array.isArray(match[0]) || !match[0].length) {
                    return;
                }
                parameters = match[0].slice();
                parameters.shift();
            }
            matches[pattern] = { event, pattern, parameters };
        });
        return matches;
    }
    on(event, callback, priority = 0) {
        Exception_1.default.require(typeof event === 'string'
            || Array.isArray(event)
            || event instanceof RegExp, 'Argument 1 expected String|RegExp (String|RegExp)[]');
        Exception_1.default.require(typeof callback === 'function', 'Argument 2 expected Function');
        Exception_1.default.require(typeof priority === 'number', 'Argument 3 expected Number');
        if (Array.isArray(event)) {
            event.forEach((event) => {
                this.on(event, callback, priority);
            });
            return this;
        }
        if (event instanceof RegExp) {
            event = event.toString();
            if (this.regexp.indexOf(event) === -1) {
                this.regexp.push(event);
            }
        }
        if (typeof this.listeners[event] === 'undefined') {
            this.listeners[event] = [];
        }
        this.listeners[event].push({ priority, callback });
        return this;
    }
    unbind(event, callback) {
        if (!event && !callback) {
            for (let key in this.listeners) {
                delete this.listeners[key];
            }
            return this;
        }
        const listener = this.listeners[event];
        if (!callback && typeof listener !== 'undefined') {
            delete this.listeners[event];
            return this;
        }
        if (typeof listener !== 'undefined' && typeof callback === 'function') {
            listener.forEach((task, i) => {
                if (callback === task.callback) {
                    listener.splice(i, 1);
                    if (!listener.length) {
                        delete this.listeners[event];
                    }
                }
            });
        }
        if (!event && typeof callback === 'function') {
            Object.keys(this.listeners).forEach(event => {
                this.listeners[event].forEach((listener, i) => {
                    if (callback === listener.callback) {
                        this.listeners[event].splice(i, 1);
                        if (!this.listeners[event].length) {
                            delete this.listeners[event];
                        }
                    }
                });
            });
        }
        return this;
    }
    use(...emitters) {
        for (let i = 0; i < emitters.length; i++) {
            Exception_1.default.require(emitters[i] instanceof EventEmitter, `Argument ${i + 1} expected EventEmitter`);
            const emitter = emitters[i];
            this.regexp = this.regexp.concat(emitter.regexp);
            this.regexp = this.regexp.filter((v, i, a) => a.indexOf(v) === i);
            for (const event in emitter.listeners) {
                const tasks = emitter.listeners[event];
                for (let j = 0; j < tasks.length; j++) {
                    this.on(event, tasks[j].callback, tasks[j].priority);
                }
            }
        }
        return this;
    }
}
exports.default = EventEmitter;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const nativeObjectProperties = [
    'constructor',
    '__proto__',
    '__defineGetter__',
    '__defineSetter__',
    'hasOwnProperty',
    '__lookupGetter__',
    '__lookupSetter__',
    'get__proto__',
    'set__proto__',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toString',
    'valueOf',
    'toLocaleString'
];
const nativeFunctionProperties = [
    'caller',
    'callee',
    'arguments',
    'apply',
    'bind',
    'call',
    ...nativeObjectProperties
];
class Reflection {
    constructor(definition) {
        this.definition = definition;
    }
    static assign(destination, ...sources) {
        for (const source of sources) {
            const properties = this.getPrototypeOf(source);
            if (!properties.length) {
                Object.assign(destination, source);
                continue;
            }
            properties.forEach(property => {
                const descriptor = Object.getOwnPropertyDescriptor(source, property);
                if (typeof descriptor !== 'object') {
                    destination[property] = source[property];
                    return;
                }
                Object.defineProperty(destination, property, descriptor);
            });
        }
        return destination;
    }
    static clone(object) {
        return this.assign({}, object);
    }
    static extends(destination, ...sources) {
        sources = sources.map(source => source.prototype);
        return this.assign(destination.prototype, ...sources);
    }
    static filter(destination, callback) {
        Reflection.getPrototypeOf(destination).forEach(property => {
            if (!callback(destination[property], property)) {
                delete destination[property];
            }
        });
        return destination;
    }
    static getArgumentNamesOf(definition) {
        if (typeof definition !== 'function') {
            return [];
        }
        let clause = definition.toString();
        if (clause.indexOf('function') !== 0) {
            clause = 'function ' + clause;
        }
        if (!clause || !clause.length) {
            return [];
        }
        const matches = clause
            .replace(/[\r\n\s]+/g, ' ')
            .match(/(?:function\s*\w*)?\s*(?:\((.*?)\)|([^\s]+))/);
        if (!matches) {
            return [];
        }
        const names = matches
            .slice(1, 3)
            .join('')
            .split(/\s*,\s*/);
        if (names.length === 1 && names[0] === '') {
            names.pop();
        }
        return names;
    }
    static getMethodNamesOf(definition, force = false) {
        if (!force && typeof definition === 'function') {
            definition = definition.prototype;
        }
        return this.getPrototypeOf(definition, force).filter(method => typeof definition[method] === 'function');
    }
    static getPropertyNamesOf(definition, force = false) {
        if (!force && typeof definition === 'function') {
            definition = definition.prototype;
        }
        return this.getPrototypeOf(definition, force).filter(method => typeof definition[method] !== 'function');
    }
    static getPrototypeOf(definition, force = false) {
        if (!force && typeof definition === 'function') {
            definition = definition.prototype;
        }
        const properties = new Set();
        let prototype = definition;
        do {
            Object.getOwnPropertyNames(prototype)
                .filter(method => {
                if (typeof definition === 'function') {
                    return nativeFunctionProperties.indexOf(method) === -1;
                }
                return nativeObjectProperties.indexOf(method) === -1;
            })
                .map(method => properties.add(method));
        } while (prototype = Object.getPrototypeOf(prototype));
        const keys = Array.from(properties.values());
        return [...keys];
    }
    static isClass(definition) {
        const clause = definition.toString();
        return clause.indexOf('class') === 0
            || clause.indexOf('_classCallCheck(this,') !== -1;
    }
    static map(destination, source, callback) {
        if (typeof source === 'function') {
            callback = source;
            source = destination;
        }
        Reflection.getPrototypeOf(source).forEach(property => {
            destination[property] = callback(source[property], property);
        });
        return destination;
    }
    static reflect(definition) {
        return new Reflection(definition);
    }
    static rename(definition, name) {
        Object.defineProperty(definition, 'name', { value: name });
        return definition;
    }
    assign(...sources) {
        Reflection.assign(this.definition, ...sources);
        return this;
    }
    clone() {
        return Reflection.clone(this.definition);
    }
    extends(...sources) {
        Reflection.extends(this.definition, ...sources);
        return this;
    }
    filter(callback) {
        Reflection.filter(this.definition, callback);
        return this;
    }
    get() {
        return this.definition;
    }
    getArgumentNames() {
        return Reflection.getArgumentNamesOf(this.definition);
    }
    getMethodNames(force) {
        return Reflection.getMethodNamesOf(this.definition, force);
    }
    getPropertyNames(force) {
        return Reflection.getPropertyNamesOf(this.definition, force);
    }
    getPrototype(force) {
        return Reflection.getPrototypeOf(this.definition, force);
    }
    implements(...parents) {
        return Reflection.implements(this.definition, ...parents);
    }
    isClass() {
        return Reflection.isClass(this.definition);
    }
    map(source, callback) {
        Reflection.map(this.definition, source, callback);
        return this;
    }
    rename(name) {
        Reflection.rename(this.definition, name);
        return this;
    }
}
exports.default = Reflection;
Reflection.implements = function (child, ...parents) {
    if (typeof child === 'function') {
        child = child.prototype;
    }
    for (let parent of parents) {
        if (typeof parent === 'function') {
            if (child instanceof parent) {
                continue;
            }
            parent = parent.prototype;
        }
        for (const method of Reflection.getMethodNamesOf(parent)) {
            if (parent[method] === child[method]) {
                continue;
            }
            if (typeof child[method] !== 'function') {
                return false;
            }
            const childClause = Reflection
                .getArgumentNamesOf(child[method])
                .join(', ');
            const parentClause = Reflection
                .getArgumentNamesOf(parent[method])
                .join(', ');
            if (childClause !== parentClause) {
                return false;
            }
        }
    }
    return true;
};
